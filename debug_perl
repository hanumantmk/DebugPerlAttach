#!/usr/bin/perl -w

use strict;

use File::Temp qw( tempfile );

use IO::Socket::INET;
use IO::Select;
use IO::Handle;

use Getopt::Long;

STDOUT->autoflush(1);

my $mode = 'stack-trace';
my $port = 50000;

GetOptions(
  '--mode=s' => \$mode,
  '--port=i' => \$port,
  '--help|?' => sub { HELP(0) },
) or HELP(1);

`which gdb` or print "gdb is a dependency\n" and exit 1;
`perl -MEnbugger -e '0'` and print "Enbugger is a dependency\n" and exit 1;

my $pid = $ARGV[0];

$pid or print "Please Enter a pid to debug\n\n" and HELP(1);

my ($fh, $fname) = tempfile(UNLINK => 1);

my $socket_code = "IO::Socket::INET->new(Timeout => 10, PeerAddr => 'localhost:$port', Proto => 'tcp')";

my %modes = (
  debugger => <<SCRIPT
    if (! \$Enbugger::DefaultDebugger) {
      require Enbugger;
      \$ENV{PERLDB_OPTS}='RemotePort=localhost:$port'
    }

    close(\$DB::OUT);
    \$DB::OUT = \$DB::IN = $socket_code;
    Enbugger->stop;
SCRIPT
  ,
  'stack-trace' => <<SCRIPT
    require Carp;
    my \$out = $socket_code;
    print \$out Carp::longmess();
    close(\$out);
SCRIPT
  ,
);

exists $modes{$mode} or print "Invalid mode $mode\n\n" and HELP(1);

my $command = $modes{$mode};
$command = make_callback($command);
$command =~ s/\n//g;

print $fh <<SCRIPT
$command

detach
quit
SCRIPT
;

close($fh) or die $!;

my $socket = IO::Socket::INET->new(
  LocalPort => $port,
  Proto     => 'tcp',
  Listen    => 1,
  ReuseAddr => 1,
);

system("gdb -q -batch -x $fname -p $pid > /dev/null &");

my @input;
my $client;

my $sel = IO::Select->new(\*STDIN, $socket);

my $keep_going = 1;

$SIG{INT} = sub {
  $keep_going = 0;
};

while ($keep_going) {
  my @ready = $sel->can_read;

  foreach my $fh (@ready) {
    if ($fh == $socket) {
      if ($client) {
	close $client;
	undef($client);
      }

      $client = $socket->accept();
      $sel->add($client);
    } elsif ($fh == \*STDIN) {
      push @input, read_something(\*STDIN);

      if ($client) {
	$client->send(join('', @input));
	@input = ();
      }
    } elsif ($fh == $client) {
      my $r = read_something($client);

      if (defined $r) {
	print $r;
      } else {
	$sel->remove($client);
	close($client);
	undef($client);
      }
    }
  }
}

exit 0;

sub make_callback {
  s/"/\\"/g for @_;

<<SCRIPT
call Perl_eval_pv(Perl_get_context(), "
  require IO::Socket::INET;
  @_
",0)
SCRIPT
}

sub read_something {
  my $fh = shift;

  my $buf;
  my $val = $fh->sysread($buf, 4096);

  if ($val) {
    return $buf;
  } else {
    return undef;
  }
}

sub HELP {
  my $exit = shift;

print <<USAGE
$0 - [ OPTIONS ] PID

Command to use gdb to attach to a running perl process and inject commands

Options:
  --mode=[stack-trace]             
         stack-trace  returns a stack trace of the running process
         debugger     sets up Enbugger in the target process and opens the debugger

  --port=[50000]      which port to talk to the remote process on

  --help|?            This help message
USAGE
;

  exit $exit;
}
